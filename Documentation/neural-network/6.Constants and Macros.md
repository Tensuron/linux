# Constants and Macros

## Overview
This document describes all constants, macros, and configuration values defined in `linux/neural.h`.

## Network Configuration Constants

### Layer Limits
```c
#define NEURAL_MAX_LAYERS 16            /* Maximum number of layers */
#define NEURAL_MAX_BATCH_SIZE 64        /* Maximum batch processing size */
```

### Input/Output Limits
```c
#define NEURAL_MAX_INPUT_SIZE 4096      /* Maximum input neurons */
#define NEURAL_MAX_OUTPUT_SIZE 1024     /* Maximum output neurons */
```

### Weight Constraints
```c
#define NEURAL_WEIGHT_SCALE 1000        /* Weight scaling factor */
#define NEURAL_MAX_WEIGHT_VALUE INT_TO_FP(100)   /* Maximum weight value */
#define NEURAL_MIN_WEIGHT_VALUE INT_TO_FP(-100)  /* Minimum weight value */
```

### Learning Parameters
```c
#define NEURAL_LEARNING_RATE_FP INT_TO_FP(1) / 1000  /* Default learning rate (0.001) */
```

## Performance Configuration

### Cache and Alignment
```c
#define NEURAL_CACHE_LINE_SIZE 64       /* Cache line size for alignment */
#define NEURAL_ALIGN __aligned(NEURAL_CACHE_LINE_SIZE)  /* Alignment macro */
```

### SIMD Thresholds
```c
#define NEURAL_SIMD_THRESHOLD 64        /* Minimum size for SIMD operations */
```

### Cache Timeout
```c
#define NEURAL_CACHE_TIMEOUT_NS (1000000000ULL)  /* Cache timeout (1 second) */
```

### NUMA Configuration
```c
#define NEURAL_MAX_NUMA_NODES 8         /* Maximum NUMA nodes supported */
```

## Model Versioning

### Version Information
```c
#define NEURAL_MODEL_VERSION 2          /* Current model format version */
#define NEURAL_MAGIC 0x4E455552         /* Magic number 'NEUR' in ASCII */
```

## Error Codes

### Success and Error Constants
```c
#define NEURAL_SUCCESS 0                        /* Operation successful */
#define NEURAL_ERROR_INVALID_INPUT -1           /* Invalid input parameters */
#define NEURAL_ERROR_MEMORY -2                  /* Memory allocation failure */
#define NEURAL_ERROR_INVALID_LAYER -3           /* Invalid layer configuration */
#define NEURAL_ERROR_INVALID_MODEL -4           /* Invalid model format */
#define NEURAL_ERROR_SIMD_UNAVAILABLE -5        /* SIMD not available */
#define NEURAL_ERROR_NUMA_FAILURE -6            /* NUMA allocation failure */
#define NEURAL_ERROR_SECURITY_VIOLATION -7      /* Security validation failed */
```

## Fixed-Point Arithmetic Macros

### Fixed-Point Format (Q16.16)
```c
#define FP_SHIFT 16                     /* Fixed-point shift amount */
#define FP_ONE (1 << FP_SHIFT)          /* Fixed-point representation of 1.0 */
```

### Arithmetic Operations
```c
#define FP_MUL(a, b) (((s64)(a) * (b)) >> FP_SHIFT)     /* Fixed-point multiplication */
#define FP_DIV(a, b) (((s64)(a) << FP_SHIFT) / (b))     /* Fixed-point division */
#define INT_TO_FP(x) ((x) << FP_SHIFT)                  /* Convert integer to fixed-point */
#define FP_TO_INT(x) ((x) >> FP_SHIFT)                  /* Convert fixed-point to integer */
#define FP_SQRT(x) neural_fp_sqrt(x)                    /* Fixed-point square root */
```

### Usage Examples
```c
// Convert values to fixed-point
s32 fp_value = INT_TO_FP(42);           // 42.0 in fixed-point
s32 fp_half = INT_TO_FP(1) / 2;         // 0.5 in fixed-point

// Arithmetic operations
s32 result = FP_MUL(fp_value, fp_half); // 42.0 * 0.5 = 21.0
s32 quotient = FP_DIV(fp_value, INT_TO_FP(2)); // 42.0 / 2.0 = 21.0

// Convert back to integer
int int_result = FP_TO_INT(result);     // 21
```

## Activation Function Types

### Activation Type Constants
```c
#define NEURAL_ACTIVATION_RELU 0        /* ReLU activation */
#define NEURAL_ACTIVATION_SIGMOID 1     /* Sigmoid activation */
#define NEURAL_ACTIVATION_LINEAR 2      /* Linear activation */
#define NEURAL_ACTIVATION_TANH 3        /* Tanh activation */
#define NEURAL_ACTIVATION_LEAKY_RELU 4  /* Leaky ReLU activation */
```

### Usage in Layer Configuration
```c
neural_layer_t layer;
layer.activation_type = NEURAL_ACTIVATION_RELU;  // Use ReLU activation
```

## Memory Alignment Macros

### Cache-Line Alignment
```c
#define NEURAL_ALIGN __aligned(NEURAL_CACHE_LINE_SIZE)
```

### Usage Example
```c
s32 *weights NEURAL_ALIGN;              /* Cache-aligned weight matrix */
s32 *biases NEURAL_ALIGN;               /* Cache-aligned bias vector */
```

## Validation Macros

### Input Validation
```c
#define NEURAL_VALIDATE_SIZE(size, max) \
    ((size) > 0 && (size) <= (max))

#define NEURAL_VALIDATE_POINTER(ptr) \
    ((ptr) != NULL)

#define NEURAL_VALIDATE_RANGE(val, min, max) \
    ((val) >= (min) && (val) <= (max))
```

### Usage Examples
```c
if (!NEURAL_VALIDATE_SIZE(input_size, NEURAL_MAX_INPUT_SIZE)) {
    return -EINVAL;
}

if (!NEURAL_VALIDATE_POINTER(nn)) {
    return -EINVAL;
}

if (!NEURAL_VALIDATE_RANGE(weight, NEURAL_MIN_WEIGHT_VALUE, NEURAL_MAX_WEIGHT_VALUE)) {
    return -EINVAL;
}
```

## Debug and Profiling Macros

### Debug Output
```c
#ifdef NEURAL_DEBUG
#define neural_debug(fmt, ...) pr_debug("Neural: " fmt, ##__VA_ARGS__)
#else
#define neural_debug(fmt, ...) do { } while (0)
#endif
```

### Performance Measurement
```c
#define NEURAL_PROFILE_START(prof) \
    do { \
        (prof)->start_time = ktime_get(); \
        (prof)->cycles_start = get_cycles(); \
    } while (0)

#define NEURAL_PROFILE_END(prof) \
    do { \
        (prof)->end_time = ktime_get(); \
        (prof)->cycles_end = get_cycles(); \
    } while (0)
```

## Configuration Macros

### Feature Enablement
```c
#ifdef CONFIG_NEURAL_NETWORK_SIMD
#define NEURAL_SIMD_ENABLED 1
#else
#define NEURAL_SIMD_ENABLED 0
#endif

#ifdef CONFIG_NEURAL_NETWORK_NUMA
#define NEURAL_NUMA_ENABLED 1
#else
#define NEURAL_NUMA_ENABLED 0
#endif
```

### Conditional Compilation
```c
#if NEURAL_SIMD_ENABLED
    /* SIMD-optimized code */
    neural_vector_add_simd(a, b, result, size);
#else
    /* Fallback implementation */
    for (i = 0; i < size; i++) {
        result[i] = a[i] + b[i];
    }
#endif
```

## Statistics Macros

### Atomic Statistics Updates
```c
#define NEURAL_STAT_INC(stat) atomic64_inc(&(stat))
#define NEURAL_STAT_ADD(stat, val) atomic64_add((val), &(stat))
#define NEURAL_STAT_READ(stat) atomic64_read(&(stat))
```

### Usage Example
```c
NEURAL_STAT_INC(nn->stats.predictions_made);
NEURAL_STAT_ADD(nn->stats.total_inference_time_ns, inference_time);
u64 total_predictions = NEURAL_STAT_READ(nn->stats.predictions_made);
```

## Security Macros

### Bounds Checking
```c
#define NEURAL_CHECK_BOUNDS(val, min, max) \
    do { \
        if ((val) < (min) || (val) > (max)) { \
            pr_err("Neural: Value %d out of bounds [%d, %d]\n", \
                   (val), (min), (max)); \
            return -EINVAL; \
        } \
    } while (0)
```

### Null Pointer Checks
```c
#define NEURAL_CHECK_NULL(ptr) \
    do { \
        if (!(ptr)) { \
            pr_err("Neural: Null pointer detected\n"); \
            return -EINVAL; \
        } \
    } while (0)
```

## Module Parameters

### Default Values
```c
static bool neural_enable_simd = true;          /* Enable SIMD by default */
static int neural_cache_timeout_ms = 1000;     /* Cache timeout in milliseconds */
static bool neural_numa_policy = false;        /* NUMA interleaving policy */
static int neural_debug_level = 0;             /* Debug verbosity level */
```

### Parameter Declarations
```c
module_param(neural_enable_simd, bool, 0644);
MODULE_PARM_DESC(neural_enable_simd, "Enable SIMD optimizations");

module_param(neural_cache_timeout_ms, int, 0644);
MODULE_PARM_DESC(neural_cache_timeout_ms, "Prediction cache timeout in milliseconds");

module_param(neural_numa_policy, bool, 0644);
MODULE_PARM_DESC(neural_numa_policy, "NUMA memory interleaving policy");
```

## Compile-Time Configuration

### Feature Detection
```c
#if defined(__x86_64__) && defined(CONFIG_X86_64)
#define NEURAL_ARCH_X86_64 1
#endif

#ifdef CONFIG_NUMA
#define NEURAL_NUMA_SUPPORT 1
#endif

#ifdef CONFIG_SMP
#define NEURAL_SMP_SUPPORT 1
#endif
```

### Optimization Hints
```c
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

#define NEURAL_HOT __attribute__((hot))
#define NEURAL_COLD __attribute__((cold))
```

## Usage Guidelines

### Performance-Critical Paths
- Use `NEURAL_ALIGN` for frequently accessed data structures
- Apply `NEURAL_HOT` attribute to performance-critical functions
- Use SIMD macros when `NEURAL_SIMD_ENABLED` is true

### Memory Management
- Always check return values against error constants
- Use NUMA-aware allocation when `NEURAL_NUMA_ENABLED` is true
- Validate all inputs using the provided validation macros

### Fixed-Point Arithmetic
- Use `INT_TO_FP()` to convert integers to fixed-point
- Use `FP_TO_INT()` to convert fixed-point back to integers
- Use `FP_MUL()` and `FP_DIV()` for arithmetic operations
- Be aware of potential overflow in fixed-point calculations
